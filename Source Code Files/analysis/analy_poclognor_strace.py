import os
from os.path import join
from public.pub_fun_analysis import *
import time

'''
This method analyzes the log file generated by strace (when the test program is the stracelog given by moonshine). 
The point of work is to extract the system calls from the file, write them to the database separated by "|".
'''

syscall_list_name = "kernel_syscall_normal_strace"


class ff_path():
    def __init__(self, src_file_path):
        self.src_file_path = src_file_path
        self.project_rootpath = os.path.abspath(os.path.dirname(__file__))
        self.srcfile_globalfull_path = join(self.project_rootpath, self.src_file_path)

    def _match_filename(self):
        file_name = []
        for root, dirs, files in os.walk(
                self.srcfile_globalfull_path):
            # print(os.path.join(root, file))
            for file in files:
                # print(file)
                file_name.append(os.path.join(root, file))
                # sum_file_name_list[file] = os.path.join(root, file)
        if len(file_name) == 0:
            print("The entered folder is empty, please check.")
        # print(sum_file_name_list)
        return file_name

    def _line_str(self, linestrs):
        linestr = str(linestrs).strip()
        if linestr.split("("):
            get_bef = linestr.split("(", 1)[0]
            if len(get_bef.split()) > 1:
                get_syscall = get_bef.split()[1]
            else:
                get_syscall = get_bef
        else:
            get_syscall = ""
        return get_syscall

    def Matchalldata_Writedb(self):
        out_txt_path = "poc_out_nor-step3"
        file_fullpath_list = self._match_filename()
        tlb_list = get_tlb(1)
        tlb_name_list = get_tlb(2)
        tlb_nameandid_list = get_tlb(3)
        # syscall_list_name = "kernel_syscall_normal_strace"
        i, cp, noi, nocall, rei, logy, nolog = 0, 0, 0, 0, 0, 0, 0
        oki, okdoc_i = 0, 0
        out_msg, out_msg_end, get_syscall, syscall_value = "", "", "", ""
        all_file_list = []
        cf_file_list = []
        max_file_list = []

        start_all_time = time.time()
        for file in file_fullpath_list:
            start_time = time.time()
            tlb_name_list = get_tlb(2)
            i += 1
            file_path = join(self.project_rootpath, file)
            file_name = os.path.split(file_path)[1]
            if not file.endswith(".log"):
                continue
            all_file_list.append(file_name)
            # print(file_path)
            print(f"Working......ID:{str(i)},FN:{file_name}")
            find_redo = mydb[syscall_list_name]
            cp = find_redo.count_documents({"kns_normal_file_name": file_name})
            if cp > 0:
                rei += 1
                print(f"The data in the library has duplicate file analysis result files, please clear and re-write.")
                cf_file_list.append(file_name)
                continue
            else:
                line_row, td_len = 0, 0
                logy += 1
                with open(file_path, "r", errors="ignore") as fs:
                    syscall_list = []
                    checklist_bad = ["+++", "---", "<...", "Cover:", "No such file or directory"]
                    for line in fs.readlines():
                        line_row += 1
                        td_len = 100000
                        if line_row % td_len == 0:
                            print(f"{int(line_row / td_len)}...", end="")
                            print("") if line_row % (td_len * 15) == 0 else print("", end="")
                        # if self.contain_str(line, checklist_bad) or not (self.contain_str(line, checklist_ok)):
                        if contain_str(line, checklist_bad) or len(line) < 2:
                            continue
                        else:
                            lines = line[0:100].strip()
                            if contain_str(lines, tlb_name_list):
                                if "(" not in line:
                                    continue
                                line = sub(" ", "", lines)
                                line_str = self._line_str(line)
                                if "[" in line_str:
                                    line_str = line_str.split("]")[1].strip()
                                if line_str not in tlb_name_list:
                                    print(f"TBL-len:{len(tlb_name_list)}")
                                    print(f"Values not in TBL: {line_str}")
                                    continue
                                syscall_list.append(line_str)
                            else:
                                continue
                        # syscall_list.append(line_str)
                    if line_row > td_len:
                        print("")
                    print("Syscall is being extracted from the normal POC Log...", end="")
                    syscall_list_end = list(filter(None, syscall_list))
                    syscall_list_counts = len(syscall_list_end)
                    if syscall_list_counts > 0:
                        syscall_value = "|".join(syscall_list_end) if syscall_list_counts > 0 else ""
                    # print(syscall_list_end)

                    print("Converting ML Sequences...", end="")
                    syscall_list_seq = []
                    print(f"Sum:{len(syscall_list_end)}...", end="")
                    if len(syscall_list_end) > 0:
                        # print(syscall_list_end)
                        for syscall_i in range(len(syscall_list_end)):
                            syscall_name = syscall_list_end[syscall_i]
                            # print(syscall_name)
                            if syscall_name in tlb_name_list:
                                syscall_name_baseid = tlb_nameandid_list[syscall_name]
                                syscall_list_seq.append(syscall_name_baseid)
                            else:
                                continue
                            # print(syscall_name_id)
                        # print(syscall_list_seq)
                    syscall_mlcode_end = list(filter(None, syscall_list_seq))
                    syscall_mlcode_counts = len(syscall_mlcode_end)
                    syscall_mlcode = "|".join(syscall_mlcode_end) if syscall_mlcode_counts > 0 else ""
                    print("Complete...")

                    k = 1000
                    kns_normal_seq_contents = "T" * (syscall_list_counts // k)

                    kns_normal_file_name = file_name
                    kns_normal_seq_list = syscall_value
                    kns_normal_mlseq_list = syscall_mlcode
                    kns_normal_seq_counts = syscall_list_counts
                    kns_normal_seq_wirte_time = time.asctime()
                    kns_normal_seq_contents = kns_normal_seq_contents

                    end_time = time.time()
                    expend_time = format((end_time - start_time), ".2f")

                # Write db
                syscall_endlist = [{"kns_normal_file_name": kns_normal_file_name,
                                    "kns_normal_seq_list": kns_normal_seq_list,
                                    "kns_normal_mlseq_list": kns_normal_mlseq_list,
                                    "kns_normal_seq_counts": kns_normal_seq_counts,
                                    "kns_normal_seq_wirte_time": kns_normal_seq_wirte_time,
                                    "kns_normal_seq_time": expend_time,
                                    "kns_normal_seq_contents": kns_normal_seq_contents
                                    }]

                file_name_sy = "sy_" + file_name
                txt_path1 = out_txt_path + "/" + file_name_sy
                with open(txt_path1, "w") as fs_txt:
                    fs_txt.write(kns_normal_seq_list)
                file_name_ml = "ml_" + file_name
                txt_path2 = out_txt_path + "/" + file_name_ml
                with open(txt_path2, "w") as fs_txt:
                    fs_txt.write(kns_normal_mlseq_list)

                doc_len = len(str(syscall_endlist))
                doc_len_kmg = str(list(Gmk_size(doc_len))[0]) + list(Gmk_size(doc_len).values())[0]
                print(f"DocSize:{doc_len_kmg}.")
                if doc_len < 15728640:
                    oki += 1
                    listwrite(syscall_list_name, syscall_endlist)
                else:
                    syscall_endlist2 = [{"kns_normal_file_name": kns_normal_file_name,
                                         "kns_normal_seq_list": f"sy_{kns_normal_file_name}",
                                         "kns_normal_mlseq_list": f"ml_{kns_normal_file_name}",
                                         "kns_normal_seq_counts": kns_normal_seq_counts,
                                         "kns_normal_seq_wirte_time": kns_normal_seq_wirte_time,
                                         "kns_normal_seq_time": expend_time,
                                         "kns_normal_seq_contents": kns_normal_seq_contents
                                         }]
                    max_file_list.append(kns_normal_file_name)
                    print(">15M")
                    okdoc_i += 1
                    listwrite(syscall_list_name, syscall_endlist2)

            out_msg = f"---Success: This success analysis No {str(i)} POC Strace Log file," \
                      f"FN:{kns_normal_file_name}, Expend Time: {expend_time}S"
            print(out_msg)

        out_file_path = out_txt_path + "/" + "readme_analy_norlogbug.txt"

        end_all_time = time.time()
        exped_time_all = format((end_all_time - start_all_time), ".2f")
        out_msg_end = f"\nAnalysis Summary: \nAnalyze the normal program trace log file {str(i)}, " \
                      f"include non-sequential files{str(nolog)}, Duplicate files{str(rei)}, Normal sequence " \
                      f"Strace Log file total {str(logy)};" \
                      f"Sequence file in which to enter the library {str(oki + okdoc_i)} (<15M {str(oki)}，" \
                      f">15M {str(okdoc_i)}),No system call {str(nocall)}；Error files {str(noi)}, " \
                      f"Total expend tiems {exped_time_all} s.\n"
        print(out_msg_end)

        with open(out_file_path, "a+") as fs2:
            fs2.write(f"\nTime：{time.strftime('%Y-%m-%d_%H-%M-%S', time.localtime())}\n")
            fs2.write(f"{out_msg_end}\n")
            fs2.write(f"The total number of files not written to the database {str(okdoc_i)}: \n")
            for file_m in max_file_list:
                fs2.write(file_m)
        # return endmsg


def Analy_main():
    src_file_path = "srcdata\\"
    # print(src_file_path)
    if src_file_path == "":
        print("The given directory is empty")
    else:
        ff_path(src_file_path).Matchalldata_Writedb()


# testing
if __name__ == '__main__':
    Analy_main()
