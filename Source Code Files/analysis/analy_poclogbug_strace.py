from re import sub
from os.path import join, abspath, dirname, split
from public.pub_fun_analysis import *
import time
import os

'''
This method analyzes the log file generated by strace during the execution of POC in syzbot. 
The main points of the work are as follows:
(1) LOG log all in the form of log into poc_out_syz or into the poc_out_exp folder, 
note: replace the log in remote with the log of the same name in local.
(2) Extract the POC system calls from the file, write the system calls to the database after separating them with "|".
(3) According to the syscall standard, the results of POC system calls are encoded with standard serial numbers 
separated by "|" and then written to the database, which is convenient for ML use.
'''

syscall_list_name = "kernel_syscallhook_bugpoc_trace_T2"
out_txt_path = "poc_out_syz-step3"


class ff_path():
    def __init__(self, src_file_path, pocsource, kelner_ver):
        self.src_file_path, self.pocsource, self.kelner_ver = src_file_path, pocsource, kelner_ver
        self.project_rootpath = abspath(dirname(__file__))
        self.srcfile_globalfull_path = join(self.project_rootpath, self.src_file_path)

    def _match_filename(self):
        file_names = []
        for root, dirs, files in os.walk(
                self.srcfile_globalfull_path):
            for file in files:
                file_names.append(join(root, file))
        if len(file_names) == 0:
            print("The entered folder is empty, please check.")
        return file_names

    def _line_str(self, linestrs):
        linestr = linestrs.strip()
        get_syscall = ""
        if linestr.split("("):
            get_syscall_all = linestr.split("(", 1)[0]
            get_syscall_all = get_syscall_all.replace("：", ":")
            if ":" in get_syscall_all:
                get_syscall = get_syscall_all.split(":")[1].strip()
            else:
                get_syscall = get_syscall_all
        else:
            get_syscall = ""
        return get_syscall

    def Matchalldata_Writedb(self):
        file_fullpath_list = self._match_filename()
        tlb_list = get_tlb(1)
        tlb_name_list = get_tlb(2)
        tlb_nameandid_list = get_tlb(3)
        i, cp, noi, nocall, rei, logy, nolog, deli = 0, 0, 0, 0, 0, 0, 0, 0
        oki, okdoc_i = 0, 0
        out_msg, out_msg_end, get_syscall, out_file_path = "", "", "", ""
        all_file_list = []
        cf_file_list = []
        failed_logname_list = []
        noanaly_logname_list = []
        max_file_list = []
        dep_del = False

        start_all_time = time.time()
        out_file_path = out_txt_path + "/" + "readme_analy_poclogbug" + self.kelner_ver + ".txt"
        # print(out_txt_path)
        for file in file_fullpath_list:
            start_time = time.time()
            i += 1
            file_names = split(file)[1]
            if not file_names.endswith(".log"):
                continue
            file_name = file_names.split(".")[0]
            all_file_list.append(file_names)

            print(f"Working......ID:{str(i)},FN:{file_names}")
            if file_name not in get_poc_c_name(self.pocsource, 2):
                nolog += 1
                noanaly_logname_list.append(file_names)
                print(f"Warning：The current LOG is not a POC file in the library，ID:{str(i)},FN:{file_name}")
                continue

            # find_relogfile = mydb[syscall_list_name]
            cp = mydb[syscall_list_name].count_documents({"kshs_poclog_name": file_name})
            if cp > 0:
                if dep_del == False:
                    rei += 1
                    seq_mycol = mydb[syscall_list_name].find_one({"kshs_poclog_name": file_name})
                    if seq_mycol["kshs_bugpoc_syscall_counts"] > 1:
                        out_msg = f"---Duplicate: the data in the library contains the analysis result document " \
                                  f"of the current file, please delete and write again.---"
                        print(out_msg)
                        cf_file_list.append(file_names)
                        continue
                    else:
                        print("Current POC LOG reanalysis")
                elif dep_del == True:
                    deli += 1
                    print(deli)
                    del_mycol = mydb[syscall_list_name].find_one_and_delete({"kshs_poclog_name": file_name})
                    print(f"Deletes the document record named ({file_name}), which will be re-analyzed the next "
                          f"time it is started.")
            else:
                line_row = 0
                con_state = True
                logy += 1
                with open(file, "r", errors="ignore") as fs:
                    syscall_list = []
                    for line_mem in fs.readlines():
                        line_row += 1
                        td_len = 100000  # Output line count every 10W lines
                        if line_row > (1000 * td_len):  # No analysis after more than 100 million lines
                            print("The document is too large, the current LOG file analysis is aborted, "
                                  "and the analysis result data is saved.")
                            break
                        if line_row % td_len == 0:  # Start counting when the LOG file is 100,000 lines
                            print(f"{int(line_row / td_len)}...", end="")
                            print("") if line_row % (td_len * 15) == 0 else print("", end="")

                        bad_exit_list = ["strace: Can", "strace:Can", "remote-log", "0，/usr/bin/sudo"]
                        if contain_str(line_mem, bad_exit_list):
                            con_state = False
                            nocall += 1
                            failed_logname_list.append(file_names)
                            out_msg = f"---Failed: The {str(i)}rd POC Strace Log file was detected not find " \
                                      f"System call，FN:{file_names}.---"
                            print(out_msg)
                            break

                        else:
                            bad_key_list = ["<...", "---", "+++", "localpocname"]
                            if contain_str(line_mem, tlb_name_list):
                                if contain_str(line_mem, bad_key_list):
                                    continue
                                if "(" not in line_mem:
                                    continue
                                linestr = line_mem.replace("aimadmin Password:", " ").strip()
                                line = sub(" ", "", linestr)
                                # print(line)
                                if "execve" in line:
                                    line = "execve"

                                line_syscall = self._line_str(line)
                                con_state = True

                                if "[" in line_syscall and "]" in line_syscall:
                                    line_syscall = line_syscall.split("]")[1].strip()

                                if line_syscall not in tlb_name_list:
                                    print(f"TBL中不存在此值:{line_syscall}")
                                    continue
                                syscall_list.append(line_syscall)
                            else:
                                continue
                            # print(syscall_list)

                    if con_state == True:
                        if line_row > td_len:
                            print("")
                        print("Extracting Syscall from POC Log...", end="")
                        syscall_list_end = list(filter(None, syscall_list))
                        syscall_list_counts = len(syscall_list_end)
                        syscall_value = "|".join(syscall_list_end) if syscall_list_counts > 0 else ""
                        # print(syscall_value)

                        # Handling system calls to ML sequences
                        print("Converting ML Sequences...", end="")
                        syscall_list_seq = []
                        print(f"Sum:{len(syscall_list_end)}...", end="")
                        if len(syscall_list_end) > 0:
                            # print(syscall_list_end)
                            for syscall_i in range(len(syscall_list_end)):
                                syscall_name = syscall_list_end[syscall_i]
                                # print(syscall_name)
                                if syscall_name in tlb_name_list:
                                    syscall_name_baseid = tlb_nameandid_list[syscall_name]
                                    syscall_list_seq.append(syscall_name_baseid)
                                else:
                                    continue
                                # print(syscall_name_id)
                            # print(syscall_list_seq)
                        syscall_mlcode_end = list(filter(None, syscall_list_seq))
                        syscall_mlcode_counts = len(syscall_mlcode_end)
                        if syscall_mlcode_counts < 1:
                            continue
                        syscall_mlcode = "|".join(syscall_mlcode_end) if syscall_mlcode_counts > 0 else ""
                        print("Complete...", end="")
                        # print(syscall_mlcode)

                        # Add flags according to the number of sys_call
                        k = 1000
                        kns_normal_seq_contents = "T" * (syscall_list_counts // k)

                        # Resulting data, write ready
                        kshs_poclog_name = file_name
                        kshs_pocsource_cls = self.pocsource
                        kshs_bugpoc_syscall_list = syscall_value
                        kshs_bugpoc_syscall_mlcode = syscall_mlcode
                        kshs_bugpoc_syscall_counts = syscall_list_counts
                        kshs_bugpoc_wirte_time = time.asctime()
                        kshs_bugpoc_contents = kns_normal_seq_contents

                        end_time = time.time()
                        expend_time = format((end_time - start_time), ".2f")
                        # Write DB
                        syscall_endlist = [{"kshs_poclog_name": kshs_poclog_name,
                                            "kshs_pocsource_cls": kshs_pocsource_cls,
                                            "kshs_kernel_ver": self.kelner_ver,
                                            "kshs_bugpoc_syscall_list": kshs_bugpoc_syscall_list,
                                            "kshs_bugpoc_syscall_mlcode": kshs_bugpoc_syscall_mlcode,
                                            "kshs_bugpoc_syscall_counts": kshs_bugpoc_syscall_counts,
                                            "kshs_bugpoc_wirte_time": kshs_bugpoc_wirte_time,
                                            "kshs_bugpoc_syscall_time": expend_time,
                                            "kshs_bugpoc_contents": kshs_bugpoc_contents
                                            }]

                        file_name_sy = "sy_" + file_name
                        txt_path1 = out_txt_path + "/" + file_name_sy + ".log"
                        with open(txt_path1, "w") as fs_txt:
                            fs_txt.write(kshs_bugpoc_syscall_list)

                        file_name_ml = "ml_" + file_name
                        txt_path2 = out_txt_path + "/" + file_name_ml + ".log"
                        with open(txt_path2, "w") as fs_txt:
                            fs_txt.write(kshs_bugpoc_syscall_mlcode)

                        doc_len = len(str(syscall_endlist))
                        doc_len_kmg = str(list(Gmk_size(doc_len))[0]) + list(Gmk_size(doc_len).values())[0]
                        print(f"DocSize:{doc_len_kmg}.")
                        if doc_len < 15728640:
                            oki += 1
                            listwrite(syscall_list_name, syscall_endlist)
                        else:
                            syscall_endlist2 = [{"kshs_poclog_name": kshs_poclog_name,
                                                 "kshs_pocsource_cls": kshs_pocsource_cls,
                                                 "kshs_kernel_ver": self.kelner_ver,
                                                 "kshs_bugpoc_syscall_list": f"sy_{kshs_poclog_name}.log",
                                                 "kshs_bugpoc_syscall_mlcode": f"ml_{kshs_poclog_name}.log",
                                                 "kshs_bugpoc_syscall_counts": kshs_bugpoc_syscall_counts,
                                                 "kshs_bugpoc_wirte_time": kshs_bugpoc_wirte_time,
                                                 "kshs_bugpoc_syscall_time": expend_time,
                                                 "kshs_bugpoc_contents": kshs_bugpoc_contents
                                                 }]
                            max_file_list.append(file_names)
                            print(
                                "Greater than 15M, only LOG files are written, Syscall and ML do not write libraries.")
                            okdoc_i += 1
                            listwrite(syscall_list_name, syscall_endlist2)

                        out_msg = f"---Success: The {str(i)}rd POC Strace Log file was analyzed successfully, " \
                                  f"FN:{file_names}，Expend Time：{expend_time}S"
                        print(out_msg)

            with open(out_file_path, "a+") as fs1:
                fs1.write(f"\nTime：{time.strftime('%Y-%m-%d_%H-%M-%S', time.localtime())}\n")
                fs1.write(f"{out_msg}\n")
            fs1.close()

        end_all_time = time.time()
        exped_time_all = format((end_all_time - start_all_time), ".2f")
        out_msg_end = f"\nAnalysis Summary (Time:{time.strftime('%Y-%m-%d_%H-%M-%S', time.localtime())}): " \
                      f"\nParse the file {str(i)}，include non-sequential files {str(nolog)}个, Duplicate " \
                      f"files{str(rei)}，POC Strace Log Sequence file total{str(logy)};" \
                      f"Sequence file in which to enter the library {str(oki + okdoc_i)}(<15M {str(oki)}, " \
                      f">15M {str(okdoc_i)})，" \
                      f"No system call {str(nocall)}; Error files {str(noi)}，Delete DB Records {str(deli)}, " \
                      f"Expend times {exped_time_all} s.\n"
        print(out_msg_end)

        with open(out_file_path, "a+") as fs2:
            fs2.write("#" * 50)
            fs2.write(f"\nTime：{time.strftime('%Y-%m-%d_%H-%M-%S', time.localtime())}\n")
            fs2.write(f"\nLog files not involved in the analysis {str(nolog)}，The list is as follows:\n")
            for noan_name in noanaly_logname_list:
                fs2.write(f"{noan_name}\n")
            fs2.write(f"\nFailure files total {str(nocall)}，The list is as follows:\n")
            for fail_name in failed_logname_list:
                fs2.write(f"{fail_name}\n")
            fs2.write(f"Total number of files not written to the database {str(okdoc_i)}: \n")
            for file_m2 in max_file_list:
                fs2.write(f"{file_m2}\n")
            fs2.write(f"{out_msg_end}\n")
        fs2.close()
        # return endmsg


def Analy_main(folder, cls, kelner_ver):
    src_file_path = f"{folder}\\" if len(folder) > 0 else "srcdataattk\\"
    pocsource = cls if len(cls) > 0 else "syzbot"
    if src_file_path == "":
        print("The given directory is empty.")
    else:
        ff_path(src_file_path, pocsource, kelner_ver).Matchalldata_Writedb()


# Current file test
if __name__ == '__main__':
    src_file_path = "srcdataattk"
    pocsource = "syzbot"
    kelner_ver = "5.0"
    Analy_main(src_file_path, pocsource, kelner_ver)
